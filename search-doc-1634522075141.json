[{"title":"Anatta","type":0,"sectionRef":"#","url":"api/Anatta","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Anatta","url":"api/Anatta#types","content":" "},{"title":"ComponentDefinition","type":1,"pageTitle":"Anatta","url":"api/Anatta#ComponentDefinition","content":"&lt;/&gt; interface ComponentDefinition { name: string type: TypeDefinition description: string? } A named TypeDefinition with an optional description. "},{"title":"Functions","type":1,"pageTitle":"Anatta","url":"api/Anatta#functions","content":" "},{"title":"createWorld","type":1,"pageTitle":"Anatta","url":"api/Anatta#createWorld","content":"&lt;/&gt; Anatta.createWorld( namespace: string, componentDefinitions: {ComponentDefinition} | Instance ) → World Creates a new World. If the second argument is a list of ComponentDefinitions, calls Registry:defineComponent on each member of the list. Otherwise, if the second argument is an Instance, calls require on all of the Instance's ModuleScript descendants and attempts to define each result.  "},{"title":"getWorld","type":1,"pageTitle":"Anatta","url":"api/Anatta#getWorld","content":"&lt;/&gt; Anatta.getWorld(namespace: string) → World Returns the World with the given namespace. "},{"title":"Dom","type":0,"sectionRef":"#","url":"api/Dom","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Dom","url":"api/Dom#functions","content":" "},{"title":"tryFromAttributes","type":1,"pageTitle":"Dom","url":"api/Dom#tryFromAttributes","content":"&lt;/&gt; Dom.tryFromAttributes( instance: Instance, componentDefinition: ComponentDefinition ) → boolean,number,any Attempts to convert the attributes of a given Instance into an entity and a component of the given ComponentDefinition. Returns a success value followed by the entity and the converted component (if successful) or an error message (if unsuccessful).  "},{"title":"tryFromDom","type":1,"pageTitle":"Dom","url":"api/Dom#tryFromDom","content":"&lt;/&gt; Dom.tryFromDom(registry: Registry) → () Attempts to load entity-component data from attributes and tags existing on all RobloxInstances in the DataModel into an empty Registry. Components defined on the given Registry determine what tag names are used to find Instances to convert. info Encountering an Instance that fails attribute validation is a soft error. Such an Instance is skipped and the reason for the failure is logged. Consumers with more granular requirements should use tryFromAttributes instead. "},{"title":"Errors","type":1,"pageTitle":"Dom","url":"api/Dom##","content":"Type\tDescription&quot;Registry must be empty&quot;\tOnly an empty Registry can load from the entire Dom.  "},{"title":"tryFromTagged","type":1,"pageTitle":"Dom","url":"api/Dom#tryFromTagged","content":"&lt;/&gt; Dom.tryFromTagged(pool: Pool) → () Attempts to convert attributes on all the Instances with the CollectionService tag matching the pool's component name into entities and components. info Encountering an Instance that fails attribute validation is a soft error. Such an Instance is skipped and the reason for the failure is logged. Consumers with more granular requirements should use tryFromAttributes instead.  "},{"title":"tryToAttributes","type":1,"pageTitle":"Dom","url":"api/Dom#tryToAttributes","content":"&lt;/&gt; Dom.tryToAttributes( instance: Instance, entity: number, componentDefinition: ComponentDefinition, component: any ) → boolean,{[string]: any]} Takes an Instance, an entity, a ComponentDefinition, and a component and attempts to convert the component into a dictionary that can be used to set attributes on the Instance. The keys of the returned dictionary are the names of the requested attributes, while the values correspond to the entity and the value(s) of the component. Returns a success value followed by the attribute dictionary (if successful) or an error message (if unsuccessful). info This function has side effects when components contain Instance references. When this is the case, a Folder is created under the given Instance and an ObjectValue under that Folder for each Instance reference. "},{"title":"Mapper","type":0,"sectionRef":"#","url":"api/Mapper","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Mapper","url":"api/Mapper#functions","content":" "},{"title":"each","type":1,"pageTitle":"Mapper","url":"api/Mapper#each","content":"&lt;/&gt; Mapper:each(callback: ( entity: number, ...any ) → ()) → () Iterates over all entities that satisfy the Query. Calls the callback for each entity, passing each entity followed by the components named in the Query. warning Adding or removing any of the components named in Query.withAll is forbidden inside of the callback. There are currently no protections against this, so be careful!  "},{"title":"map","type":1,"pageTitle":"Mapper","url":"api/Mapper#map","content":"&lt;/&gt; Mapper:map(callback: ( entity: number, ...any ) → ...any) → () Maps over entities that satisfy the Query. Calls the callback for each entity, passing each entity followed by the components named in the Query, and replaces the components in Query.withAll with the callback's return value. The replacement is equivalent a Registry:replaceComponent call. warning Adding or removing any of the components named in Query.withAll is forbidden inside of the callback. There are currently no protections against this, so be careful! "},{"title":"Reactor","type":0,"sectionRef":"#","url":"api/Reactor","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Reactor","url":"api/Reactor#functions","content":" "},{"title":"consume","type":1,"pageTitle":"Reactor","url":"api/Reactor#consume","content":"&lt;/&gt; Reactor:consume(entity: number) → () Consumes updates made to components named in Query.withUpdated. "},{"title":"Errors","type":1,"pageTitle":"Reactor","url":"api/Reactor##","content":"Type\tDescription&quot;entity %d is not present in this reactor&quot;\tThe reactor doesn't contain that entity.  "},{"title":"consumeEach","type":1,"pageTitle":"Reactor","url":"api/Reactor#consumeEach","content":"&lt;/&gt; Reactor:consumeEach(callback: ( entity: number, ...any ) → ()) → () Iterates over all the entities present in the Reactor and clears each entity's update status. Calls the callback for each entity visited during the iteration, passing the entity followed by the components named in the Query. This function effectively &quot;consumes&quot; all updates made to components named inQuery.withUpdated, emptying the Reactor. A consumer that wants to selectively consume updates should use consume instead. info It's safe to add or remove components inside of the callback.  "},{"title":"each","type":1,"pageTitle":"Reactor","url":"api/Reactor#each","content":"&lt;/&gt; Reactor:each(callback: ( entity: number, ...any ) → ()) → () Iterates over the all the entities present in the Reactor. Calls the callback for each entity, passing each entity followed by the components named in the Query. info It's safe to add or remove components inside of the callback.  "},{"title":"withAttachments","type":1,"pageTitle":"Reactor","url":"api/Reactor#withAttachments","content":"&lt;/&gt; Reactor:withAttachments(callback: ( entity: number, ...any ) → {RBXScriptConnection | Instance}) → () Calls the callback every time an entity enters the Reactor, passing each entity and its components and attaching the return value to each entity. The callback should return a list of connections and/or Instances. When the entity later leaves the Reactor, attached Instances are destroyed and attached connections are disconnected. warning Yielding inside of the callback is forbidden. There are currently no protections against this, so be careful! "},{"title":"T","type":0,"sectionRef":"#","url":"api/T","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"T","url":"api/T#types","content":" "},{"title":"TypeDefinition","type":1,"pageTitle":"T","url":"api/T#TypeDefinition","content":"&lt;/&gt; interface TypeDefinition { check: (...) typeParams: {TypeDefinition} typeName: string } A wrapped t check returned by each member function. "},{"title":"World","type":0,"sectionRef":"#","url":"api/World","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"World","url":"api/World#types","content":" "},{"title":"Query","type":1,"pageTitle":"World","url":"api/World#Query","content":"&lt;/&gt; interface Query { withAll: {ComponentDefinition}? withUpdated: {ComponentDefinition}? withAny: {ComponentDefinition}? without: {ComponentDefinition}? } A Query represents a set of entities to retrieve from a Registry. A Query can be finalized by passing it to World:getReactor or World:getMapper. The fields of a Query determine which entities are yielded. Each field is an optional list of ComponentsDefinitions that corresponds to a rule: Field Rule withAll An entity must have all of these components. withUpdated An entity must have an updated copy of all of these components. withAny An entity may have any or none of these components. without An entity must not have any of these components. note A Mapper cannot track updates to components. World:getMapper throws an error when passed a Query containing a withUpdated field. Using queries Methods like Reactor:each and Mapper:map take callbacks that are passed an entity and its components. The components go in a specific order: first the components from withAll, then the components from withUpdated, and finally the components from withAny. The order of the fields in Query has no effect on this - dictionaries don't have a defined order in Lua! Here are some example signatures using made-up components: local world = Anatta.getWorld(&quot;TheOverworld&quot;) local components = world.components local registry = world.registry local Ascendant = components.Ascendant local Blessed = components.Blessed local Human = components.Human local Immortal = components.Immortal local Magicka = components.Magicka local thePowerful = world:getMapper({ withAll = { Human, Blessed }, withAny = { Magicka }, }) thePowerful:map(function(entity, human, blessed, magicka) return human, blessed end) local demigods = world:getReactor({ withUpdated = { Blessed }, withAll = { Human, Immortal }, }) demigods:each(function(entity, human, immortal, blessed) end) local ascendantDivineBeings = world:getReactor({ without = { Human }, withAny = { Magicka }, withAll = { Blessed, Immortal }, withUpdated = { Ascendant }, }) ascendantDivineBeings:each(function(entity, blessed, immortal, ascendant, magicka) end) warning Sometimes we define &quot;tag&quot; components that look like this: local T = require(Packages.Anatta).T return { name = &quot;Blessed&quot;, type = T.none, } Tag components always have a value of nil. That means: local entity = registry:createEntity() registry:addComponent(entity, Blessed) assert(registry:getComponent(entity, Blessed) == nil, &quot;Tag components are equal to nil!&quot;) And also: world:getMapper({ withAll = { Blessed }, }):map(function(entity, blessed) assert(blessed == nil, &quot;Tag components are equal to nil!&quot;) end) The correct way to check for the existence of tag components (and in general) is withRegistry:entityHas or Registry:entityHasAny. "},{"title":"Properties","type":1,"pageTitle":"World","url":"api/World#properties","content":" "},{"title":"components","type":1,"pageTitle":"World","url":"api/World#components","content":"&lt;/&gt; World.components: {[string]: ComponentDefinition} A dictionary mapping component names to component definitions. Intended to be used for importing component definitions as follows: -- Assuming we've already defined the World elsewhere with a component called &quot;Money&quot; local world = Anatta:getWorld(&quot;MyCoolWorld&quot;) local registry = world.registry local Money = world.components.Money registry:addComponent(registry:createEntity(), Money, 5000)   "},{"title":"registry","type":1,"pageTitle":"World","url":"api/World#registry","content":"&lt;/&gt; World.registry: Registry Provides direct, unscoped access to a World's Registry. "},{"title":"Functions","type":1,"pageTitle":"World","url":"api/World#functions","content":" "},{"title":"getMapper","type":1,"pageTitle":"World","url":"api/World#getMapper","content":"&lt;/&gt; World:getMapper(query: Query) → Mapper Creates a new Mapper given a Query. "},{"title":"Errors","type":1,"pageTitle":"World","url":"api/World##","content":"Type\tDescription&quot;mappers cannot track updates to components; use a Reactor instead&quot;\tReactors can track updates. Mappers can't. &quot;mappers need at least one component type provided in withAll&quot;\tMappers need components in withAll to query. 'the component type &quot;%s&quot; is not defined for this world&quot;\tNo component matches that definition.  "},{"title":"getReactor","type":1,"pageTitle":"World","url":"api/World#getReactor","content":"&lt;/&gt; World:getReactor(query: Query) → Reactor Creates a new Reactor given a Query. "},{"title":"Errors","type":1,"pageTitle":"World","url":"api/World##","content":"Type\tDescription&quot;reactors need at least one component type provided in withAll, withUpdated, or withAny&quot;\tReactors need components to query. &quot;reactors can only track up to 32 updated component types&quot;\tMore than 32 components were provided in withUpdated. 'the component type &quot;%s&quot; is not defined for this world&quot;\tNo component matches that definition. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"Introduction","keywords":""},{"title":"A Pattern Born for Live-Service Games","type":0,"sectionRef":"#","url":"docs/why-roblox-ecs/live-service-pattern","content":"A Pattern Born for Live-Service Games Most games on Roblox are developed as live-service games. They are also called games as a service or simply live games. Regardless of the term we use, it just refers to games that use a recurring revenue model. Development doesn't stop after launch; the product is continuously upgraded and sold. This usually means that a decent chunk of development time will be spent creating content for the game: new cosmetic items, gameplay areas, storylines, promotional events. A lot of this work is done by artists and designers, and not necessarily programmers. So, one of the top concerns for a live-service game is the frequency and regularity of its content updates. But there's a problem: players in multiplayer games talk to each other. They share personal knowledge and secrets of the game. which is good for community effects, but can have the unfortunate side effect of players consuming content much faster than they otherwise would. The problem gets worse the larger and more intertwined a game's community becomes. How easy is it for artists and designers to get their content into the game (and working)? How often can they do it without needing a programmer? New game content often requires a part of the game logic to change or work with another part in unanticipated ways. Other times players have discovered a game-breaking strategy that demands a change to an integral part of the game logic. The code must be easy to change and debug: requirements that cut right across engineering concerns are inevitably introduced (&quot;can you make me a gun that shoots swords?&quot;), and it's important that the programming model doesn't resist change or fall apart in fundamental ways when it does happen. Different components of the game logic need to easily compose in a loose, decoupled way. As experiences grow larger and more complex, there is an ever-increasing amount of data to worry about persisting. This may bring to mind things like players' storyline progress, collectibles, stats, and lifetime achievements, but it also includes things like item types, ability types, and even different areas and zones in the game. All of this data may one day be important for a live-service game. It needs to be kept in a format that's easy to store, inspect, and transform. Content is data. Properly planning for it can have outsized impact on ease of development. ECS allows almost everything to be data-driven, from the schema of the game objects, to the various component parts of the game logic. Scott Bilas discovered this in 2002's Dungeon Siege; now, we're rediscovering it for Roblox.","keywords":""},{"title":"Registry","type":0,"sectionRef":"#","url":"api/Registry","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Registry","url":"api/Registry#functions","content":" "},{"title":"addAndReplaceComponent","type":1,"pageTitle":"Registry","url":"api/Registry#addAndReplaceComponent","content":"&lt;/&gt; Registry:addAndReplaceComponent( entity: number, definition: ComponentDefinition, component: any ) → any Adds the component to the entity, immediately replacing the component with itself, and returns the component. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. &quot;entity %d already has a %s&quot;\tThe entity already has that component. Failed type check\tThe given component has the wrong type.  "},{"title":"addComponent","type":1,"pageTitle":"Registry","url":"api/Registry#addComponent","content":"&lt;/&gt; Registry:addComponent( entity: number, definition: ComponentDefinition, component: any ) → any Adds a component to the entity and returns the component. info An entity can only have one component of each type at a time. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. &quot;entity %d already has a %s&quot;\tThe entity already has that component. Failed type check\tThe given component has the wrong type.  "},{"title":"addOrReplaceComponent","type":1,"pageTitle":"Registry","url":"api/Registry#addOrReplaceComponent","content":"&lt;/&gt; Registry:addOrReplaceComponent( entity: number, definition: ComponentDefinition, component: any ) → any If the entity has the component, replaces it with the given component and returns the new component. Otherwise, adds the component to the entity and returns the new component. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. Failed type check\tThe given component has the wrong type.  "},{"title":"countComponents","type":1,"pageTitle":"Registry","url":"api/Registry#countComponents","content":"&lt;/&gt; Registry:countComponents(definition: ComponentDefinition) → number Returns the total number of entities with the given component. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"countEntities","type":1,"pageTitle":"Registry","url":"api/Registry#countEntities","content":"&lt;/&gt; Registry:countEntities() → number Returns the total number of entities currently in use by the registry.  "},{"title":"createEntity","type":1,"pageTitle":"Registry","url":"api/Registry#createEntity","content":"&lt;/&gt; Registry:createEntity() → number Creates and returns a unique identifier that represents a game object. Usage: local entity = registry:createEntity() assert(entity == 1) entity = registry:createEntity() assert(entity == 2) entity = registry:createEntity() assert(entity == 3)   "},{"title":"destroyEntity","type":1,"pageTitle":"Registry","url":"api/Registry#destroyEntity","content":"&lt;/&gt; Registry:destroyEntity(entity: number) → () Removes all of an entity's components and frees its ID. Usage: local entity = registry:create() registry:destroyEntity(entity) -- the entity is no longer valid and functions like getComponent or addComponent will throw assert(registry:entityIsValid(entity) == false)  "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid.  "},{"title":"each","type":1,"pageTitle":"Registry","url":"api/Registry#each","content":"&lt;/&gt; Registry:each(callback: (entity: number) → ()) → () Passes each entity currently in use by the registry to the given callback.  "},{"title":"entityHas","type":1,"pageTitle":"Registry","url":"api/Registry#entityHas","content":"&lt;/&gt; Registry:entityHas( entity: number, ...: ComponentDefinition ) → boolean Returns true if the entity all of the given components. Otherwise, returns false. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"entityHasAny","type":1,"pageTitle":"Registry","url":"api/Registry#entityHasAny","content":"&lt;/&gt; Registry:entityHasAny( entity: number, ...: ComponentDefinition ) → boolean Returns true if the entity has any of the given components. Otherwise, returns false. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"entityIsOrphaned","type":1,"pageTitle":"Registry","url":"api/Registry#entityIsOrphaned","content":"&lt;/&gt; Registry:entityIsOrphaned(entity: number) → boolean Returns true if the entity has no components. Otherwise, returns false. Usage local entity = registry:createEntity() assert(self:entityIsOrphaned(entity) == true) registry:addComponent(entity, Car, { model = game.ReplicatedStorage.Car:Clone(), color = &quot;Red&quot;, }) assert(registry:entityIsOrphaned(entity) == false)  "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid.  "},{"title":"entityIsValid","type":1,"pageTitle":"Registry","url":"api/Registry#entityIsValid","content":"&lt;/&gt; Registry:entityIsValid(entity: number) → boolean Returns true if the entity exists. Otherwise, returns false. Usage: assert(registry:entityIsValid(0) == false) local entity = registry:createEntity() assert(registry:entityIsValid(entity) == true) registry:destroyEntity(entity) assert(registry:entityIsValid(entity) == false)   "},{"title":"getComponent","type":1,"pageTitle":"Registry","url":"api/Registry#getComponent","content":"&lt;/&gt; Registry:getComponent( entity: number, definition: ComponentDefinition ) → any Returns the component of the given type on the entity. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"getComponents","type":1,"pageTitle":"Registry","url":"api/Registry#getComponents","content":"&lt;/&gt; Registry:getComponents( entity: number, output: table, ...: ComponentDefinition ) → ...any Returns all of the given components on the entity. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"getOrAddComponent","type":1,"pageTitle":"Registry","url":"api/Registry#getOrAddComponent","content":"&lt;/&gt; Registry:getOrAddComponent( entity: number, definition: ComponentDefinition, component: any ) → () If the entity has the component, returns the component. Otherwise adds the component to the entity and returns the component. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. Failed type check\tThe given component has the wrong type.  "},{"title":"isComponentDefined","type":1,"pageTitle":"Registry","url":"api/Registry#isComponentDefined","content":"&lt;/&gt; Registry:isComponentDefined(definition: ComponentDefinition) → boolean Returns true if the registry has a component type with the given name. Otherwise, returns false.  "},{"title":"removeComponent","type":1,"pageTitle":"Registry","url":"api/Registry#removeComponent","content":"&lt;/&gt; Registry:removeComponent( entity: number, definition: ComponentDefinition ) → () Removes the component from the entity. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. &quot;entity %d does not have a %s&quot;\tThe entity is expected to have this component.  "},{"title":"replaceComponent","type":1,"pageTitle":"Registry","url":"api/Registry#replaceComponent","content":"&lt;/&gt; Registry:replaceComponent( entity: number, definition: ComponentDefinition, component: any ) → any Replaces the given component on the entity and returns the new component. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. Failed type check\tThe given component has the wrong type. &quot;entity %d does not have a %s&quot;\tThe entity is expected to have this component.  "},{"title":"tryAddComponent","type":1,"pageTitle":"Registry","url":"api/Registry#tryAddComponent","content":"&lt;/&gt; Registry:tryAddComponent( entity: number, definition: ComponentDefinition, component: any ) → any If the entity does not have the component, adds and returns the component. Otherwise, returns nil. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. Failed type check\tThe given component has the wrong type.  "},{"title":"tryRemoveComponent","type":1,"pageTitle":"Registry","url":"api/Registry#tryRemoveComponent","content":"&lt;/&gt; Registry:tryRemoveComponent( entity: number, definition: ComponentDefinition ) → boolean If the entity has the component, removes it and returns true. Otherwise, returns false. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition.  "},{"title":"visitComponents","type":1,"pageTitle":"Registry","url":"api/Registry#visitComponents","content":"&lt;/&gt; Registry:visitComponents( callback: (definition: ComponentDefinition) → boolean, entity: number? ) → boolean Passes all the component names defined on the registry to the given callback. The iteration continues until the callback returns nil. If an entity is given, passes only the components that the entity has. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid.  "},{"title":"withComponents","type":1,"pageTitle":"Registry","url":"api/Registry#withComponents","content":"&lt;/&gt; Registry:withComponents( entity: number, components: {[ComponentDefinition]: any} ) → number Adds the given components to the entity and returns the entity. "},{"title":"Errors","type":1,"pageTitle":"Registry","url":"api/Registry##","content":"Type\tDescription&quot;expected entity to be a number, got %s&quot;\tThe entity is not a number. &quot;entity %d does not exist or has been destroyed&quot;\tThe entity is invalid. 'the component type &quot;%s&quot; is not defined for this registry'\tNo component matches that definition. &quot;entity %d already has a %s&quot;\tThe entity already has that component. Failed type check\tThe given component has the wrong type. "}]