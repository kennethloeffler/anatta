"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4],{77799:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new `World` containing an empty [`Registry`](/api/Registry) and calls\\n[`Registry:defineComponent`](/api/Registry#defineComponent) for each\\n[`ComponentDefinition`](/api/Anatta#ComponentDefinition) in the given list.","params":[{"name":"definitions","desc":"","lua_type":"{ComponentDefinition}"}],"returns":[{"desc":"","lua_type":"World"}],"function_type":"static","ignore":true,"source":{"line":172,"path":"lib/src/World/init.lua"}},{"name":"getMapper","desc":"Creates a new [`Mapper`](/api/Mapper) given a [`Query`](#Query).","params":[{"name":"query","desc":"","lua_type":"Query"}],"returns":[{"desc":"","lua_type":"Mapper"}],"function_type":"method","errors":[{"lua_type":"\\"mappers cannot track updates to components; use a Reactor instead\\"","desc":"Reactors can track updates. Mappers can\'t."},{"lua_type":"\\"mappers need at least one component type provided in withAll\\"","desc":"Mappers need components in withAll to query."},{"lua_type":"\'the component type \\"%s\\" is not defined for this world\\"","desc":"No component matches that definition."}],"source":{"line":355,"path":"lib/src/World/init.lua"}},{"name":"getReactor","desc":"Creates a new [`Reactor`](/api/Reactor) given a [`Query`](#Query).","params":[{"name":"query","desc":"","lua_type":"Query"}],"returns":[{"desc":"","lua_type":"Reactor"}],"function_type":"method","errors":[{"lua_type":"\\"reactors need at least one component type provided in withAll, withUpdated, or withAny\\"","desc":"Reactors need components to query."},{"lua_type":"\\"reactors can only track up to 32 updated component types\\"","desc":"More than 32 components were provided in withUpdated."},{"lua_type":"\'the component type \\"%s\\" is not defined for this world\\"","desc":"No component matches that definition."}],"source":{"line":381,"path":"lib/src/World/init.lua"}}],"properties":[{"name":"registry","desc":"Provides direct, unscoped access to a `World`\'s [`Registry`](/api/Registry).","lua_type":"Registry","source":{"line":14,"path":"lib/src/World/init.lua"}},{"name":"components","desc":"A dictionary mapping component names to component definitions. Intended to be used for importing\\ncomponent definitions as follows:\\n```lua\\n-- Assuming we\'ve already defined the World elsewhere with a component called \\"Money\\"\\nlocal world = Anatta:getWorld(\\"MyCoolWorld\\")\\nlocal registry = world.registry\\n\\nlocal Money = world.components.Money\\n\\nregistry:addComponent(registry:createEntity(), Money, 5000)\\n```","lua_type":"{[string]: ComponentDefinition}","source":{"line":162,"path":"lib/src/World/init.lua"}}],"types":[{"name":"Query","desc":"A `Query` represents a set of entities to retrieve from a\\n[`Registry`](/api/Registry). A `Query` can be finalized by passing it to\\n[`World:getReactor`](#getReactor) or [`World:getMapper`](#getMapper).\\n\\nThe fields of a `Query` determine which entities are yielded. Each field is an\\noptional list of `ComponentsDefinition`s that corresponds to a rule:\\n\\n| Field       | Rule                                                            |\\n|-------------|-----------------------------------------------------------------|\\n| withAll     | An entity must have all of these components.                    |\\n| withUpdated | An entity must have an updated copy of all of these components. |\\n| withAny     | An entity may have any or none of these components.             |\\n| without     | An entity must not have any of these components.                |\\n\\n:::note\\nA [`Mapper`](/api/Mapper) cannot track updates to\\ncomponents. [`World:getMapper`](#getMapper) throws an error when passed a `Query`\\ncontaining a `withUpdated` field.\\n:::\\n\\n### Using queries\\n\\nMethods like [`Reactor:each`](/api/Reactor#each) and [`Mapper:map`](/api/Mapper#map)\\ntake callbacks that are passed an entity and its components. The components go in a\\nspecific order: first the components from `withAll`, then the components from\\n`withUpdated`, and finally the components from `withAny`. The order of the fields\\nin `Query` has no effect on this - dictionaries don\'t have a defined order in Lua!\\nHere are some example signatures using made-up components:\\n\\n```lua\\nlocal world = Anatta.getWorld(\\"TheOverworld\\")\\nlocal components = world.components\\nlocal registry = world.registry\\n\\nlocal Ascendant = components.Ascendant\\nlocal Blessed = components.Blessed\\nlocal Human = components.Human\\nlocal Immortal = components.Immortal\\nlocal Magicka = components.Magicka\\n\\nlocal thePowerful = world:getMapper({\\n\\twithAll = { Human, Blessed },\\n\\twithAny = { Magicka },\\n})\\n\\nthePowerful:map(function(entity, human, blessed, magicka)\\n\\treturn human, blessed\\nend)\\n\\nlocal demigods = world:getReactor({\\n\\twithUpdated = { Blessed },\\n\\twithAll = { Human, Immortal },\\n})\\n\\ndemigods:each(function(entity, human, immortal, blessed)\\nend)\\n\\nlocal ascendantDivineBeings = world:getReactor({\\n\\twithout = { Human },\\n\\twithAny = { Magicka },\\n\\twithAll = { Blessed, Immortal },\\n\\twithUpdated = { Ascendant },\\n})\\n\\nascendantDivineBeings:each(function(entity, blessed, immortal, ascendant, magicka)\\nend)\\n```\\n\\n:::warning\\nSometimes we define \\"tag\\" components that look like this:\\n```lua\\nlocal T = require(Packages.Anatta).T\\n\\nreturn {\\n\\tname = \\"Blessed\\",\\n\\ttype = T.none,\\n}\\n```\\nTag components always have a value of `nil`. That means:\\n```lua\\nlocal entity = registry:createEntity()\\n\\nregistry:addComponent(entity, Blessed)\\n\\nassert(registry:getComponent(entity, Blessed) == nil, \\"Tag components are equal to nil!\\")\\n```\\nAnd also:\\n```lua\\nworld:getMapper({\\n\\twithAll = { Blessed },\\n}):map(function(entity, blessed)\\n\\tassert(blessed == nil, \\"Tag components are equal to nil!\\")\\nend)\\n```\\n\\nThe correct way to check for the existence of tag components (and in general) is with\\n[`Registry:entityHas`](/api/Registry#entityHas) or\\n[`Registry:entityHasAny`](/api/Registry#entityHasAny).\\n:::","fields":[{"name":"withAll","lua_type":"{ComponentDefinition}?","desc":""},{"name":"withUpdated","lua_type":"{ComponentDefinition}?","desc":""},{"name":"withAny","lua_type":"{ComponentDefinition}?","desc":""},{"name":"without","lua_type":"{ComponentDefinition}?","desc":""}],"source":{"line":123,"path":"lib/src/World/init.lua"}}],"name":"World","desc":"A `World` contains a [`Registry`](/api/Registry) and provides means for both scoped and\\nunscoped access to entities and components.\\n\\nYou can get or create a `World` with [`Anatta.getWorld`](/api/Anatta#getWorld) and\\n[`Anatta.createWorld`](/api/Anatta#createWorld).","source":{"line":10,"path":"lib/src/World/init.lua"}}')}}]);