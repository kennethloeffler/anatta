"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4],{77799:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new `World` containing an empty [`Registry`](Registry) and calls\\n[`Registry:defineComponent`](Registry#defineComponent) for each\\n[`ComponentDefinition`](Anatta#ComponentDefinition) in the given list.","params":[{"name":"componentDefinitions","desc":"","lua_type":"{ComponentDefinition}"}],"returns":[{"desc":"","lua_type":"World"}],"function_type":"static","ignore":true,"source":{"line":31,"path":"lib/src/World/init.lua"}},{"name":"getMapper","desc":"Creates a new [`Mapper`](Mapper) given a [`Query`](#Query).","params":[{"name":"query","desc":"","lua_type":"Query"}],"returns":[{"desc":"","lua_type":"Mapper"}],"function_type":"method","errors":[{"lua_type":"\\"Mappers cannot track updates to components\\"","desc":""},{"lua_type":"\\"Mappers need at least one component type specified in withAll\\"","desc":""}],"source":{"line":53,"path":"lib/src/World/init.lua"}},{"name":"getReactor","desc":"Creates a new [`Reactor`](Reactor) given a [`Query`](#Query).","params":[{"name":"query","desc":"","lua_type":"Query"}],"returns":[{"desc":"","lua_type":"Reactor"}],"function_type":"method","errors":[{"lua_type":"\\"Reactors need at least one component type specified in withAll, withUpdated, or withAny\\"","desc":""},{"lua_type":"\\"Reactors can only track up to 32 updated component types\\"","desc":""}],"source":{"line":66,"path":"lib/src/World/init.lua"}}],"properties":[{"name":"registry","desc":"Provides direct, unscoped access to a `World`\'s [`Registry`](Registry).","lua_type":"Registry","source":{"line":14,"path":"lib/src/World/init.lua"}}],"types":[{"name":"Query","desc":"A `Query` represents a component aggregation to retrieve from a\\n[`Registry`](Registry). A `Query` can be finalized by passing it to\\n[`World:getReactor`](#getReactor) or [`World:getMapper`](#getMapper).\\n\\nVarious [`Reactor`](Reactor) and [`Mapper`](Mapper) methods accept callbacks that are\\npassed an entity and its components. Such callbacks receive the entity as the first\\nargument, followed by the entity\'s components from `withAll`, then the components from\\n`withUpdated`, and finally the components from `withAny`.\\n\\n### `Query.withAll`\\nAn entity must have all of the components specified in `withAll` to appear in the\\nquery.\\n\\n### `Query.withUpdated`\\nAn entity must have an updated copy of all the components specified in `withUpdated`\\nto appear in the query.\\n\\n### `Query.withAny`\\nAn entity may have any or none of the components specified in `withAny` and still\\nappear in the query.\\n\\n### `Query.without`\\nAn entity must not have any of the components specified in `without` to appear in the\\nquery.","fields":[{"name":"withAll","lua_type":"{string}?","desc":""},{"name":"withUpdated","lua_type":"{string}?","desc":""},{"name":"withAny","lua_type":"{string}?","desc":""},{"name":"without","lua_type":"{string}?","desc":""}],"source":{"line":55,"path":"lib/src/Types.lua"}}],"name":"World","desc":"A `World` contains a [`Registry`](Registry) and provides means for both scoped and\\nunscoped access to entities and components.\\n\\nYou can get or create a `World` with [`Anatta.getWorld`](Anatta#getWorld) and\\n[`Anatta.createWorld`](Anatta#createWorld).","source":{"line":10,"path":"lib/src/World/init.lua"}}')}}]);